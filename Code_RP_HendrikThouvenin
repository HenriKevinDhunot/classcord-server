python
# serveur.py
import socket
import threading
import json
import pickle
import os
from datetime import datetime

HOST = '0.0.0.0'
PORT = 12345

USER_FILE = 'users.pkl'

LOCK = threading.Lock()
CLIENTS = {}  # socket -> username
USERS = {}    # username -> password


def load_users():
    global USERS
    if os.path.exists(USER_FILE):
        with open(USER_FILE, 'rb') as f:
            USERS = pickle.load(f)
    print(f"[INIT] Utilisateurs chargés: {list(USERS.keys())}")


def save_users():
    with open(USER_FILE, 'wb') as f:
        pickle.dump(USERS, f)
    print("[SAVE] Utilisateurs sauvegardés.")


def broadcast(message, sender=None):
    message_bytes = (json.dumps(message) + '\n').encode()
    with LOCK:
        for client, username in list(CLIENTS.items()):
            if client != sender:
                try:
                    client.sendall(message_bytes)
                except:
                    print(f"[ERREUR] Client {username} déconnecté.")
                    CLIENTS.pop(client, None)


def handle_client(client_socket):
    buffer = ''
    username = None
    address = client_socket.getpeername()
    print(f"[CONNEXION] {address}")

    try:
        while True:
            data = client_socket.recv(1024)
            if not data:
                break
            buffer += data.decode()

            while '\n' in buffer:
                line, buffer = buffer.split('\n', 1)
                if not line.strip():
                    continue
                try:
                    msg = json.loads(line)
                except:
                    continue

                if msg['type'] == 'register':
                    with LOCK:
                        if msg['username'] in USERS:
                            response = {'type': 'error', 'message': 'Username already exists.'}
                        else:
                            USERS[msg['username']] = msg['password']
                            save_users()
                            response = {'type': 'register', 'status': 'ok'}
                        client_socket.sendall((json.dumps(response) + '\n').encode())

                elif msg['type'] == 'login':
                    with LOCK:
                        if USERS.get(msg['username']) == msg['password']:
                            username = msg['username']
                            CLIENTS[client_socket] = username
                            response = {'type': 'login', 'status': 'ok'}
                            client_socket.sendall((json.dumps(response) + '\n').encode())
                            broadcast({'type': 'status', 'user': username, 'state': 'online'}, client_socket)
                        else:
                            response = {'type': 'error', 'message': 'Login failed.'}
                            client_socket.sendall((json.dumps(response) + '\n').encode())

                elif msg['type'] == 'message' and username:
                    msg['from'] = username
                    msg['timestamp'] = datetime.now().isoformat()
                    broadcast(msg, client_socket)

                elif msg['type'] == 'status' and username:
                    broadcast({'type': 'status', 'user': username, 'state': msg['state']}, client_socket)

    finally:
        if username:
            broadcast({'type': 'status', 'user': username, 'state': 'offline'}, client_socket)
        with LOCK:
            CLIENTS.pop(client_socket, None)
        client_socket.close()
        print(f"[DECONNEXION] {address}")


def main():
    load_users()
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEAD_


²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²

python
# client_test.py
import socket
import json
import threading

HOST = '127.0.0.1'
PORT = 12345

def receive_loop(sock):
    buffer = ''
    while True:
        data = sock.recv(1024).decode()
        buffer += data
        while '\n' in buffer:
            line, buffer = buffer.split('\n', 1)
            print(f"[SERVEUR] {line}")

def main():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((HOST, PORT))
    threading.Thread(target=receive_loop, args=(s,), daemon=True).start()

    print("Tapez vos commandes JSON (Ctrl+C pour quitter):")
    try:
        while True:
            line = input("> ")
            msg = json.loads(line)
            s.sendall((json.dumps(msg) + '\n').encode())
    except KeyboardInterrupt:
        s.close()

if __name__ == '__main__':
    main()


²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²

python
import hashlib

def hash_password(password):
    return hashlib.sha256(password.encode()).hexdigest()

²

python
# Lors du register :
USERS[msg['username']] = hash_password(msg['password'])

# Lors du login :
if USERS.get(msg['username']) == hash_password(msg['password']):


²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²

python
# client.py
import socket
import json
import threading

HOST = '127.0.0.1'
PORT = 12345

def listen(sock):
    buffer = ''
    while True:
        try:
            data = sock.recv(1024).decode()
            if not data:
                break
            buffer += data
            while '\n' in buffer:
                line, buffer = buffer.split('\n', 1)
                msg = json.loads(line)
                if msg['type'] == 'message':
                    print(f"[{msg['timestamp']}] {msg['from']}: {msg['content']}")
                elif msg['type'] == 'status':
                    print(f"*** {msg['user']} est maintenant {msg['state']} ***")
                elif msg['type'] == 'error':
                    print(f"!!! ERREUR: {msg['message']}")
        except:
            break

def main():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((HOST, PORT))
    threading.Thread(target=listen, args=(s,), daemon=True).start()

    print("Commandes : register, login, message, status")
    username = None
    try:
        while True:
            cmd = input("> ")
            parts = cmd.split(" ", 1)
            if parts[0] == "register":
                user, pwd = parts[1].split()
                s.sendall((json.dumps({'type': 'register', 'username': user, 'password': pwd}) + '\n').encode())
            elif parts[0] == "login":
                user, pwd = parts[1].split()
                username = user
                s.sendall((json.dumps({'type': 'login', 'username': user, 'password': pwd}) + '\n').encode())
            elif parts[0] == "message":
                s.sendall((json.dumps({'type': 'message', 'content': parts[1]}) + '\n').encode())
            elif parts[0] == "status":
                s.sendall((json.dumps({'type': 'status', 'state': parts[1]}) + '\n').encode())
    except KeyboardInterrupt:
        s.close()

if __name__ == '__main__':
    main()


²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²²

bash
# vide car standard lib utilisée uniquement

²

dockerfile
FROM python:3.11
WORKDIR /app
COPY . .
CMD ["python", "serveur.py"]

²

md
# ClassCord - Serveur de chat local
Serveur de messagerie TCP avec enregistrement, login, gestion de statut, en Python.

## Utilisation
```bash
python serveur.py        # Démarre le serveur
python client_test.py    # Client JSON brut
python client.py         # Client CLI interactif

²

json
{"type": "register", "username": "bob", "password": "1234"}
{"type": "login", "username": "bob", "password": "1234"}
{"type": "message", "content": "Bonjour à tous"}
{"type": "status", "state": "away"}

²

bash
docker build -t classcord .
docker run -p 12345:12345 classcord

²

yaml

---

